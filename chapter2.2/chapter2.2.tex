\chapter{Software}
\label{chap:software}
Die Software die im Rahmen dieser Arbeit entwickelt wurde, ist in C++ geschrieben. Als Entwicklungsumgebung wurde Eclipse mit den \ac{CDT} auf einem Linux\footnote{Ubuntu 12.04 LTS}  Betriebssystem verwendet.
\section{Simulation}
\label{sec:simulation}
Grundlage der Simulation ist das 3D Grafiktoolkit \ac{OCG}\footnote{\url{http://www.openscenegraph.org/}}. Damit lässt sich eine 3D Szene in Form eines Graphen aufbauen und mit einem Viewer darstellen. Um den Ablauf kontrollieren zu können, lässt sich die Render-Schleife manuell aufrufen um jeden Frame einzeln berechnen zu lassen. Dies wurde als Simulationsschritt gewählt in dem alle nötigen Berechnungen durchgeführt werden können. Da die Geschwindigkeit mit der die Simulation im manuellen Modus abläuft nicht begrenzt wird, wurde eine Mindestbearbeitungszeit integriert. Denn die Geschwindigkeiten von Objekten in der Simulation, wie dem Roboter, werden durch eine zurückgelegte Strecke pro Simulationsschritt festgelegt. Bei sehr schneller Hardware ergab dies eine zu hohe Bewegungsrate um den Roboter noch manuell steuern zu können. Für automatisierte Simulationsläufe mit festgelegten Fahrprofilen könnte man diese Begrenzung wieder lösen um Zeit zu sparen.

\subsection{Die Szene}
\label{subsec:dieSzene}
\begin{description} 
\item[Die Grundfläche] der Bühne misst 12 x 12 m. Sie wird als einfach weiße Fläche in der Szene dargestellt. Da die Bildverarbeitung nur auf den Oberen Teil des Bildes beschränkt ist, spielen Farbe und Helligkeit keine Rolle bei der Erkennung des Musters im Bild.
\end{description}
 
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{chapter2.2/bildderszene.png}
    \caption[Bild Simulierte Szene]{Bild Simulierte Szene}
    \label{fig:bildderszene}
\end{figure}

\begin{description}
\item[Die Lichtwände] sind zu drei Seiten der Grundfläche aufgestellt. Sie messen 3m in der Höhe und 8m  in der Länge. Wie bereits in @@@@@@@@ beschrieben soll das Muster in der obersten Zeile der Lichtwände dargestellt werden. Hierzu können verschiedene Texturen geladen werden die das Bitmuster enthalten. In der Realität sind die Lichtwände auf der Bühne sind aus 1 x 1 Meter großen Segmenten zusammen gesetzt, dies wird in der Simulation nicht abgebildet. Es wäre jedoch denkbar, dies in den Aufbau der Texturen einfließen zu lassen. Also leichte Abstands Änderungen der Bits in der Textur.
Auf jedem Segment sind 8 x 8 Bits unter gebracht. Das macht eine Kantenlänge von 125 mm bei jedem dieser Pixel und 64 Pixel über die ganze Länge einer Wand. Ein solches Segment besteht aus einer Milchigen Plexiglasplatte, die auf eine Struktur geschraubt wurde die für jedes Pixel ein Leuchtmittel vorsieht. Dessen Helligkeit lässt sich einstellen, wäre aber für das Bitmuster auf die Zustände: dunkel(ausgeschaltet) oder hell(ein, mit größter Helligkeit) einzustellen. Die Plexiglasplatte wird also pro Pixel von Hinten durchleuchtet. Dies führt dazu, das die Helligkeitsverteilung in einem beleuchteten Pixle inhomogen ist. In der Mitte ist die größte Helligkeit, während sie radial nach Außen etwas abnimmt. Die Ecken der Pixle sind die dunkelsten Stellen. Auf Abbildung \ref{fig:RobotAndLightwall} auf Seite \pageref{fig:RobotAndLightwall} ist dieser Effekt gut zu sehen. Er wird besonders stark, wenn die Leuchtmittel mit niedriger Helligkeit betrieben werden. Bei hoher Helligkeit ist der Effekt noch wahrnehmbar, aber nicht mehr so ausgeprägt. Und noch etwas fällt auf wenn man dieses Bild betrachtet, die Lichtfarbe und Helligkeit variiert leicht von Pixel zu Pixel. All diese Effekte können in der Simulation nur durch verändern der Texturen abgebildet werden.

\item[Der Roboter] @@@@@@@@@@@@@@@ Platzhalter @@@@@@@@@@@@ Er lässt sich mit den Tasten W, A, S, D (vorwärts, links, rückwärts, rechts) grob verfahren oder mit einem Gamepad mit Analogsticks auch präziser steuern. Die Steuerbefehle für den Roboter werden in Geschwindigkeit (gerade aus) und Drehrate interpretiert. Diese führen dann, in jedem Simulationsschritt zu einer Positionsänderung in Richtung der Orientierung und einer anschließenden Änderung der Orientierung um die Drehrate. <------( Implementierung möglicherweise noch ändern??? ) . Aus diesen Positions- und Orientierungsänderungen werden in einem Weiteren Schritt Drehwinkeländerungen der Beiden Räder berechnet. Dies ist der "wahre" Zustand der Odometrie in der Simulation. Aus diesen Winkelstellungen\footnote{Die Winkelstellung der Räder wird nur numerisch simuliert und ist am Modell nicht sichtbar.}  der Räder wird ein Wert für die Inkrementalgeber abgeleitet und auf ganze Inkremente gerundet. Dabei gibt es einen Parameter $\sigma_{increment}$ der zu einem Gaußschen in den Inkrementen führt. <---(mehr details???) 

\item[Passanten oder Besucher] @@@@@@@@@@@ Platzhalter @@@@@@@@@@@

\item[Partikel] werden zur Veranschaulichung und zu debugging Zwecken visualisiert. Sie werden durch rote kleine spitze Dreiecke dargestellt. Der spitze Winkel zeigt dabei die Orientierung an. Sie befinden sich nur auf dem Boden und beeinträchtigen die Bildverarbeitung deshalb nicht.
\end{description}

\section{Lokalisation}
\label{sec:lokalisation}

